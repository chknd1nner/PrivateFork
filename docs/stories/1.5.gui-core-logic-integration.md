# Story 1.5: GUI and Core Logic Integration

## Status
Approved

## Story
**As a** user,
**I want** to click the "Create Private Fork" button in the app and have it perform the complete operation,
**so that** I can use the graphical interface to manage the process.

## Acceptance Criteria
1. Clicking the "Create Private Fork" button triggers the core automation logic.
2. The application uses the URL from the input field and the selected local path as parameters for the logic.
3. The application retrieves the saved GitHub credentials from the Keychain to authenticate.
4. During the operation, real-time status updates from the core logic are displayed in the main view's status label.
5. Upon successful completion, a "Success!" message is displayed.
6. The "Create Private Fork" button is disabled while an operation is in progress.

## Tasks / Subtasks
- [ ] Create PrivateForkOrchestrator service to coordinate all operations (AC: 1, 2, 3, 4)
  - [ ] Create Services/Protocols/PrivateForkOrchestratorProtocol.swift
  - [ ] Create Services/Implementations/PrivateForkOrchestrator.swift
  - [ ] Implement async orchestration workflow: validateCredentials → createRepository → cloneAndPush
  - [ ] Add dependency injection for GitHubService, GitService, and KeychainService
  - [ ] Implement progress reporting with status update callbacks
- [ ] Update MainViewModel to integrate PrivateForkOrchestrator (AC: 1, 2, 4, 5, 6)
  - [ ] Add PrivateForkOrchestrator dependency injection to MainViewModel
  - [ ] Implement createPrivateFork() method that calls orchestrator
  - [ ] Add status update handling to display real-time progress
  - [ ] Implement UI state management (isForking, button disabled state)
  - [ ] Add success/error message handling with appropriate user feedback
- [ ] Implement comprehensive error handling (AC: 5)
  - [ ] Handle credential validation errors from KeychainService
  - [ ] Handle GitHub API errors from GitHubService  
  - [ ] Handle Git operation errors from GitService
  - [ ] Display user-friendly error messages in status area
  - [ ] Ensure proper error recovery and UI state reset
- [ ] Create comprehensive unit tests
  - [ ] Create PrivateForkTests/Services/PrivateForkOrchestratorTests.swift
  - [ ] Create PrivateForkTests/Mocks/MockPrivateForkOrchestrator.swift
  - [ ] Test successful end-to-end workflow orchestration
  - [ ] Test error handling for each service layer failure
  - [ ] Test status update callbacks and progress reporting
  - [ ] Update MainViewModelTests to test integration with orchestrator
- [ ] Integration testing and end-to-end validation (AC: All)
  - [ ] Test complete workflow from button click to success message
  - [ ] Validate UI state changes during operation (button disabled, status updates)
  - [ ] Test error scenarios and proper error message display
  - [ ] Ensure all services work together correctly through orchestrator

## Dev Notes

### Previous Story Insights
From Story 1.2: Complete KeychainService implementation provides secure credential storage and retrieval. From Story 1.3: MainView UI components are ready with repository URL input, directory selection, and Create Private Fork button. From Story 1.4a: CLI foundation provides patterns for async operations. From Story 1.4b: GitHubService provides complete GitHub API integration with authentication and repository creation. From Story 1.4c: GitService provides complete Git automation with clone, remote configuration, and push operations.

### Project Structure
Following the MVVM pattern from the source tree, the orchestrator components should be organized as:
- **Services/Protocols/PrivateForkOrchestratorProtocol.swift**: Protocol defining orchestration workflow [Source: docs/architecture/source-tree.md#services]
- **Services/Implementations/PrivateForkOrchestrator.swift**: Concrete implementation coordinating all services [Source: docs/architecture/source-tree.md#services]
- **ViewModels/MainViewModel.swift**: Updated to use orchestrator for createPrivateFork() [Source: docs/architecture/source-tree.md#viewmodels]

### Component Standards Requirements
PrivateForkOrchestrator must follow the established service pattern:
- Orchestrator must conform to PrivateForkOrchestratorProtocol for dependency injection
- All methods must be async and return Result types
- Service must be injectable into ViewModels during initialization
- Follow the same pattern as established in GitHubService and GitService
[Source: docs/architecture/component-standards.md#component-template]

### Coding Standards Requirements
- **Protocol-Oriented Programming (POP)**: PrivateForkOrchestrator must be abstracted behind PrivateForkOrchestratorProtocol [Source: docs/architecture/coding-standards.md#critical-coding-rules]
- **Dependency Injection**: Orchestrator will be injected into MainViewModel during initialization [Source: docs/architecture/coding-standards.md#critical-coding-rules]
- **Asynchronous Operations**: All orchestration workflow must use async/await [Source: docs/architecture/coding-standards.md#critical-coding-rules]
- **Result Type for Outcomes**: All orchestrator operations must return Result<Success, Error> [Source: docs/architecture/coding-standards.md#critical-coding-rules]
- **Single Responsibility Principle**: Orchestration logic belongs only in PrivateForkOrchestrator [Source: docs/architecture/coding-standards.md#critical-coding-rules]
- **@MainActor**: MainViewModel must remain marked with @MainActor for UI updates [Source: docs/architecture/coding-standards.md#critical-coding-rules]

### Technology Stack
- **Framework**: Foundation for async coordination, SwiftUI for UI state management [Source: docs/architecture/tech-stack.md]
- **Language**: Swift 5.10+ [Source: docs/architecture/tech-stack.md]
- **Dependencies**: Native Apple frameworks only, existing service dependencies [Source: docs/architecture/tech-stack.md]
- **Architecture**: MVVM with Protocol-Oriented Programming [Source: docs/architecture/tech-stack.md]

### Orchestrator Service Pattern
The PrivateForkOrchestrator must follow this template pattern:
```swift
protocol PrivateForkOrchestratorProtocol {
    func createPrivateFork(
        repositoryURL: String,
        localPath: String,
        statusCallback: @escaping (String) -> Void
    ) async -> Result<String, Error>
}

@MainActor
class PrivateForkOrchestrator: PrivateForkOrchestratorProtocol {
    private let keychainService: KeychainServiceProtocol
    private let gitHubService: GitHubServiceProtocol
    private let gitService: GitServiceProtocol
    
    // Coordinate all services with status updates
}
```
[Source: Patterns from Stories 1.2, 1.4b, 1.4c]

### Orchestration Workflow Design
The complete workflow must implement these sequential steps:
1. **Credential Validation**: Retrieve and validate GitHub credentials from Keychain
2. **Repository Creation**: Create private repository on GitHub using GitHubService
3. **Git Operations**: Clone public repo, configure remotes, push to private repo using GitService
4. **Status Reporting**: Provide real-time status updates throughout the workflow
5. **Error Handling**: Handle failures at any step with proper cleanup and user feedback

### Service Integration Patterns
Building on established patterns from previous stories:
- Use the same dependency injection pattern as MainViewModel and SettingsViewModel
- Follow the same Result<Success, Error> pattern from GitHubService and GitService
- Use async/await patterns established in all previous service implementations
- Maintain the same mock patterns for testing established in previous stories
[Source: Stories 1.2, 1.4a, 1.4b, 1.4c]

### MainViewModel Integration Updates
MainViewModel updates must follow these requirements:
- Add PrivateForkOrchestrator as injected dependency following existing patterns
- Update createPrivateFork() method to use orchestrator instead of placeholder logic
- Implement status update callback to update @Published statusMessage property
- Add isForking state management to disable UI during operation
- Handle success and error states with appropriate user messages
[Source: docs/architecture/state-management.md#state-management-template]

### Progress Reporting and UI State Management
Status updates must provide real-time feedback:
- "Validating credentials..." during credential check
- "Creating private repository..." during GitHub API call
- "Cloning repository..." during Git clone operation
- "Configuring remotes..." during Git remote setup
- "Pushing to private repository..." during Git push
- "Success!" upon completion or specific error messages on failure

### Error Handling Patterns
Comprehensive error handling for all service layers:
- **Credential Errors**: "Invalid or missing GitHub credentials. Please check your settings."
- **GitHub API Errors**: "Failed to create repository: [specific GitHub error]"
- **Git Errors**: "Git operation failed: [specific Git error]"
- **Network Errors**: "Network connection failed. Please check your internet connection."
- **General Errors**: "An unexpected error occurred: [error description]"

### Integration with Existing Services
This story builds on all previous services:
- **KeychainService**: Use existing credential retrieval patterns
- **GitHubService**: Use existing repository creation patterns  
- **GitService**: Use existing Git operation patterns
- **MainViewModel**: Follow existing state management patterns
- **SettingsViewModel**: Reference existing credential validation patterns
[Source: Previous stories 1.2, 1.3, 1.4a, 1.4b, 1.4c]

### Security and Data Handling
- Never log or expose GitHub credentials in status messages or errors
- Use secure credential handling through existing KeychainService only
- Validate all user inputs (repository URL, local path) before processing
- Handle sensitive data appropriately throughout the orchestration workflow
- Ensure proper cleanup of any temporary data on errors

### Testing

**Run Tests**: Use XcodeBuildMCP tool: test_macos_proj, fallback: Execute `xcodebuild test -scheme PrivateFork -quiet`

**Expected Result**: All tests must pass before story completion - no exceptions.

**Test File Locations:**
- PrivateForkTests/Services/PrivateForkOrchestratorTests.swift (new file for orchestrator testing)
- PrivateForkTests/Mocks/MockPrivateForkOrchestrator.swift (new file for mocking in other tests)
- PrivateForkTests/ViewModels/MainViewModelTests.swift (update existing for orchestrator integration)

**Component Test Template for PrivateForkOrchestrator:**
```swift
import XCTest  
@testable import PrivateFork

@MainActor
final class PrivateForkOrchestratorTests: XCTestCase {

    var orchestrator: PrivateForkOrchestrator!  
    var mockKeychainService: MockKeychainService!
    var mockGitHubService: MockGitHubService!
    var mockGitService: MockGitService!

    override func setUp() {  
        super.setUp()  
        // REQUIRED: Inject mock dependencies
        mockKeychainService = MockKeychainService()
        mockGitHubService = MockGitHubService()
        mockGitService = MockGitService()
        orchestrator = PrivateForkOrchestrator(
            keychainService: mockKeychainService,
            gitHubService: mockGitHubService,
            gitService: mockGitService
        )
    }

    func testCreatePrivateFork_WhenSuccessful_ShouldCompleteWorkflow() async {  
        // Given: All services configured for success
        mockKeychainService.setRetrieveResult(.success(GitHubCredentials(...)))
        mockGitHubService.setCreateRepoResult(.success(...))
        mockGitService.setCloneResult(.success(...))
        
        var statusUpdates: [String] = []

        // When: The orchestration workflow is called  
        let result = await orchestrator.createPrivateFork(
            repositoryURL: "https://github.com/user/repo",
            localPath: "/tmp/test",
            statusCallback: { statusUpdates.append($0) }
        )

        // Then: The operation should succeed with proper status updates
        switch result {
        case .success(let message):
            XCTAssertEqual(message, "Success!")
            XCTAssertTrue(statusUpdates.contains("Validating credentials..."))
            XCTAssertTrue(statusUpdates.contains("Creating private repository..."))
        case .failure:
            XCTFail("Orchestration should have succeeded")
        }
    }  
}
```

**Critical Implementation Requirements:**
- **Test Environment Protection**: PrivateForkOrchestrator must use dependency injection with mock services for all tests
- **Async Testing**: Use async/await test functions for all orchestration operations
- **Status Callback Testing**: Verify that status updates are called at appropriate workflow steps
- **Error Scenarios**: Test all service failure modes and ensure proper error propagation
- **Integration Testing**: Test the complete workflow with all services working together

**Mandatory Testing Standards:**
- **XCTest Framework**: Use XCTest consistently across all test targets
- **Given-When-Then Structure**: Strictly follow Arrange-Act-Assert pattern
- **Mock Dependencies**: All service dependencies MUST be mocked in unit tests
- **Coverage Goals**: Maintain >90% code coverage on PrivateForkOrchestrator logic
- **MainViewModel Integration**: Update existing MainViewModel tests to cover orchestrator usage

**Specific Testing Requirements for This Story:**
- **Workflow Orchestration**: Test successful completion of all steps in sequence
- **Status Updates**: Test that status callback is called with appropriate messages
- **Error Handling**: Test failure at each step and ensure proper error propagation
- **UI State Management**: Test MainViewModel integration for button states and status display
- **Service Coordination**: Test that services are called in correct order with proper data flow

## Change Log
| Date       | Version | Description                           | Author |
|------------|---------|---------------------------------------|--------|
| 2025-07-20 | 0.1     | Initial GUI integration story draft   | SM     |

## Dev Agent Record
*This section is populated by the development agent during implementation*

## QA Results
*Results from QA Agent QA review of the completed story implementation*