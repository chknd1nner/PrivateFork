# Story 1.4d: CLI Integration and Complete Automation

## Status
Draft

## Story
**As a** power user,
**I want** a complete command-line interface that orchestrates all services to perform the entire private fork operation,
**so that** I can integrate the private fork utility into scripts and automated workflows.

## Acceptance Criteria
1. When launched with the required arguments, the app performs the entire private fork automation process without showing a GUI.
2. The core logic successfully creates a private repo, clones the public repo, configures remotes, and pushes to the new private origin.
3. The process prints status updates to the standard output (e.g., "Cloning...", "Success!").
4. The process exits with a non-zero status code if any step in the automation fails.
5. The complete workflow integrates all services (CLI, GitHub, Git) seamlessly.

## Tasks / Subtasks
- [ ] Create CLI orchestration controller (AC: 1, 5)
  - [ ] Implement CLIController class to coordinate all services
  - [ ] Integrate CLIService, GitHubService, and GitService
  - [ ] Add dependency injection for all required services
  - [ ] Implement complete workflow coordination
- [ ] Implement end-to-end automation workflow (AC: 2)
  - [ ] Step 1: Validate arguments and credentials (using CLIService)
  - [ ] Step 2: Create private repository (using GitHubService)
  - [ ] Step 3: Clone public repository (using GitService)
  - [ ] Step 4: Configure remotes (using GitService)
  - [ ] Step 5: Push to private repository (using GitService)
  - [ ] Add proper error handling between steps
- [ ] Implement real-time status reporting (AC: 3)
  - [ ] Add status output to stdout for each workflow step
  - [ ] Implement progress indicators for long-running operations
  - [ ] Add detailed logging for debugging purposes
  - [ ] Ensure clean, user-friendly output formatting
- [ ] Implement comprehensive error handling and exit codes (AC: 4)
  - [ ] Define specific exit codes for each failure type
  - [ ] Add proper error cleanup on failures
  - [ ] Implement rollback operations where possible
  - [ ] Add detailed error reporting to stderr
- [ ] Integrate with main application entry point (AC: 1)
  - [ ] Modify PrivateForkApp.swift to detect CLI vs GUI mode
  - [ ] Add CLI mode initialization and execution
  - [ ] Ensure GUI is not initialized in CLI mode
  - [ ] Add proper application lifecycle management
- [ ] Create comprehensive integration tests
  - [ ] Test complete end-to-end workflow scenarios
  - [ ] Test error handling at each workflow step
  - [ ] Test status output and exit codes
  - [ ] Test integration between all services
  - [ ] Test rollback scenarios on failures

## Dev Notes

### Previous Story Insights
From Story 1.4a: CLI argument parsing and credential validation infrastructure is ready. From Story 1.4b: GitHubService provides private repository creation with proper error handling. From Story 1.4c: GitService provides Git automation with comprehensive shell command execution. This story integrates all three to provide the complete automation workflow.

### Project Structure
Following the MVVM pattern from the source tree, CLI integration components should be organized as:
- **Application/PrivateForkApp.swift**: Modified to support CLI mode detection and initialization [Source: docs/architecture/source-tree.md#application]
- **Controllers/CLIController.swift**: New controller to orchestrate CLI workflow [Source: docs/architecture/source-tree.md - new pattern]
- **Models/PrivateForkWorkflow.swift**: Data models for workflow state and progress [Source: docs/architecture/source-tree.md#models]
- **Utilities/CLIOutput.swift**: Utilities for formatted CLI output and logging [Source: docs/architecture/source-tree.md#utilities]

### Component Standards
CLI controller must follow established patterns:
- CLIController coordinates services but doesn't implement business logic
- All service dependencies must be injected for testability
- Controller methods must be async and return Result types
- Follow the same coordination pattern as ViewModels
[Source: docs/architecture/component-standards.md#component-template]

### Coding Standards Requirements
- **MVVM Pattern**: CLIController acts like a ViewModel for CLI operations [Source: docs/architecture/coding-standards.md#critical-coding-rules]
- **Dependency Injection**: All services injected into CLIController during initialization [Source: docs/architecture/coding-standards.md#critical-coding-rules]
- **Asynchronous Operations**: Complete workflow must use async/await throughout [Source: docs/architecture/coding-standards.md#critical-coding-rules]
- **Result Type for Outcomes**: All workflow steps must return Result types [Source: docs/architecture/coding-standards.md#critical-coding-rules]
- **Single Responsibility**: CLIController coordinates, services implement [Source: docs/architecture/coding-standards.md#critical-coding-rules]

### Technology Stack
- **Framework**: Foundation for application lifecycle and process management [Source: docs/architecture/tech-stack.md]
- **Language**: Swift 5.10+ [Source: docs/architecture/tech-stack.md]
- **Dependencies**: Native Apple frameworks only, integrating all previous services [Source: docs/architecture/tech-stack.md]
- **Application**: SwiftUI app with CLI mode detection [Source: docs/architecture/tech-stack.md]

### Service Integration Pattern
CLI controller must coordinate all services:
```swift
@MainActor
class CLIController {
    private let cliService: CLIServiceProtocol
    private let githubService: GitHubServiceProtocol
    private let gitService: GitServiceProtocol
    
    init(cliService: CLIServiceProtocol,
         githubService: GitHubServiceProtocol,
         gitService: GitServiceProtocol) {
        self.cliService = cliService
        self.githubService = githubService
        self.gitService = gitService
    }
    
    func executePrivateFork() async -> Result<String, Error> {
        // Coordinate all services for complete workflow
    }
}
```
[Source: docs/architecture/api-integration.md#service-template]

### Workflow Step Specifications
The complete automation workflow must follow this sequence:
1. **Argument Validation**: Use CLIService to parse and validate arguments
2. **Credential Check**: Use CLIService to validate GitHub credentials
3. **Repository Creation**: Use GitHubService to create private repository
4. **Repository Clone**: Use GitService to clone public repository
5. **Remote Configuration**: Use GitService to set up origin and upstream
6. **Push Operation**: Use GitService to push to new private repository
7. **Success Confirmation**: Report completion and cleanup

### Error Handling and Rollback
Each workflow step must handle failures:
- **Validation Failures**: Exit early with clear error messages
- **Repository Creation Failures**: No cleanup needed
- **Clone Failures**: Clean up partial directory creation
- **Remote Configuration Failures**: Clean up cloned repository
- **Push Failures**: Repository exists but may need manual intervention

### Exit Code Specifications
Define specific exit codes for different scenarios:
- 0: Success
- 1: General error
- 2: Invalid arguments
- 3: Missing credentials
- 4: GitHub API failure
- 5: Git operation failure
- 6: Network/connectivity failure

### Status Output Format
CLI output must be user-friendly and scriptable:
- Progress indicators for long operations
- Clear success/failure messages
- Detailed error information when needed
- Consistent formatting for parsing

### Integration with Application Lifecycle
Modify PrivateForkApp.swift to:
- Detect CLI mode from command-line arguments
- Initialize CLI mode without SwiftUI components
- Handle application termination properly
- Manage service lifecycle for CLI operations

### Integration with Previous Services
This story builds on all previous service implementations:
- CLIService from Story 1.4a for argument parsing and validation
- GitHubService from Story 1.4b for repository creation
- GitService from Story 1.4c for Git automation
- KeychainService from Story 1.2 for credential management
[Source: Previous stories 1.2, 1.4a, 1.4b, 1.4c]

### Performance Considerations
- Optimize workflow for minimal latency
- Provide progress feedback for long operations
- Handle large repository cloning efficiently
- Manage memory usage during operations

### Security Considerations
- Ensure credentials are never logged or exposed
- Validate all user inputs to prevent injection
- Handle temporary files securely
- Clean up sensitive data on exit

### Testing

**Run Tests**: Use XcodeBuildMCP tool: test_macos_proj, fallback: Execute `xcodebuild test -scheme PrivateFork -quiet`

**Expected Result**: All tests must pass before story completion - no exceptions.

**Test File Locations:**
- PrivateForkTests/Controllers/CLIControllerTests.swift (new file for CLI controller testing)
- PrivateForkTests/Integration/EndToEndCLITests.swift (new file for complete workflow testing)
- PrivateForkTests/Integration/DualLaunchIntegrationTests.swift (enhanced for CLI/GUI mode detection)
- PrivateForkTests/Models/PrivateForkWorkflowTests.swift (new file for workflow model testing)
- PrivateForkTests/Utilities/CLIOutputTests.swift (new file for output utility testing)

**Component Test Template for CLIController:**
```swift
import XCTest  
@testable import PrivateFork

@MainActor
final class CLIControllerTests: XCTestCase {

    var cliController: CLIController!  
    var mockCLIService: MockCLIService!
    var mockGitHubService: MockGitHubService!
    var mockGitService: MockGitService!

    override func setUp() {  
        super.setUp()  
        // REQUIRED: Inject all mock services - parameterless init will crash in tests
        mockCLIService = MockCLIService()
        mockGitHubService = MockGitHubService()
        mockGitService = MockGitService()
        cliController = CLIController(
            cliService: mockCLIService,
            githubService: mockGitHubService,
            gitService: mockGitService
        )  
    }

    func testExecutePrivateFork_WhenAllServicesSucceed_ShouldReturnSuccess() async {  
        // Given: All services configured for success  
        mockCLIService.validateResult = .success(())
        mockGitHubService.createPrivateRepoResult = .success("newrepo")
        mockGitService.cloneResult = .success("cloned")
        mockGitService.configureRemotesResult = .success("configured")
        mockGitService.pushResult = .success("pushed")

        // When: The complete workflow is executed  
        let result = await cliController.executePrivateFork()

        // Then: The workflow should succeed  
        switch result {
        case .success(let message):
            XCTAssertTrue(message.contains("Success"))
        case .failure:
            XCTFail("Workflow should have succeeded")
        }
    }  
}
```

**Integration Testing Requirements:**
- **DualLaunchIntegrationTests**: Test `AppLauncher.shouldRunInCLIMode()` for CLI/GUI mode detection
- **End-to-End Workflow**: Test complete automation process with real component integration
- **Service Coordination**: Validate proper service interaction and data flow
- **Error Rollback**: Test cleanup operations when workflow steps fail

**Critical Implementation Requirements:**
- **Test Environment Protection**: CLIController must use dependency injection for all services
- **AppLauncher Testing**: Test CLI/GUI mode detection using `AppLauncher.shouldRunInCLIMode()`
- **Exit Code Validation**: Test all defined exit codes (0-6) for different failure scenarios
- **Status Output Testing**: Validate CLI output formatting and progress indicators

**Mandatory Testing Standards:**
- **XCTest Framework**: Use XCTest consistently across all test targets
- **Bundle IDs**: Maintain unique bundle identifiers for each test target
- **Given-When-Then Structure**: Strictly follow Arrange-Act-Assert pattern
- **Mock Dependencies**: ALL service dependencies MUST be mocked in unit tests
- **Integration Tests**: Test real component interactions in PrivateForkTests/Integration/
- **Performance**: Unit tests should complete in <100ms per test

**Specific Testing Requirements for This Story:**
- **End-to-End Workflow**: Test complete automation from CLI args to success/failure
- **Service Integration**: Test coordination between CLIService, GitHubService, GitService
- **Error Scenarios**: Test failure handling at each workflow step with proper exit codes
- **Rollback Operations**: Test cleanup on various failure points (clone, push, etc.)
- **Status Output**: Test all status messages, progress indicators, and formatting
- **Exit Codes**: Test all exit code scenarios (0=success, 1-6=different failures)
- **Application Lifecycle**: Test CLI vs GUI mode detection and proper initialization
- **AppLauncher Integration**: Test mode detection logic comprehensively

## Change Log
| Date       | Version | Description                           | Author |
|------------|---------|---------------------------------------|--------|
| 2025-07-17 | 0.1     | Initial CLI integration story from 1.4 split | SM     |

## Dev Agent Record
*This section is populated by the development agent during implementation*

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

## QA Results