# Story 1.4a: CLI Interface Foundation

## Status
Draft

## Story
**As a** power user,
**I want** a command-line interface foundation that can parse arguments and validate credentials,
**so that** I can begin using the private fork operation from the command line.

## Acceptance Criteria
1. The application can be launched from the terminal.
2. The application accepts command-line arguments for the public repository URL and the local destination path.
3. When launched with the required arguments, the app validates arguments and credentials without showing a GUI.
4. If the CLI is launched without credentials having been configured in the Keychain, it prints a clear error message and instructs the user to launch the GUI to configure them.
5. The process exits with a non-zero status code if argument parsing or credential validation fails.

## Tasks / Subtasks
- [ ] Create CLI argument parsing infrastructure (AC: 1, 2)
  - [ ] Add CLI argument parsing using Swift's ArgumentParser or native CommandLine
  - [ ] Define CLI argument structure for repo URL and local path
  - [ ] Add argument validation (URL format, path validity)
  - [ ] Add help text and usage instructions
- [ ] Implement headless mode detection (AC: 3)
  - [ ] Add logic to detect CLI vs GUI launch mode
  - [ ] Prevent GUI initialization when in CLI mode
  - [ ] Add CLI-specific initialization flow
- [ ] Integrate credential validation (AC: 4)
  - [ ] Use existing KeychainService to check for saved credentials
  - [ ] Add CLI-specific error messages for missing credentials
  - [ ] Add user guidance to configure credentials via GUI
- [ ] Implement CLI error handling and exit codes (AC: 5)
  - [ ] Define exit code constants for different failure scenarios
  - [ ] Add proper error reporting to stderr
  - [ ] Add success reporting to stdout
- [ ] Create comprehensive unit tests
  - [ ] Test argument parsing with valid and invalid inputs
  - [ ] Test headless mode detection
  - [ ] Test credential validation scenarios
  - [ ] Test error handling and exit codes

## Dev Notes

### Previous Story Insights
From Story 1.2: The project successfully implements secure credential management with KeychainService, which can be reused for CLI credential validation. From Stories 1.3a-d: The GUI foundation is complete with URL validation, directory selection, and credential state management that provides patterns for CLI implementation.

### Project Structure
Following the MVVM pattern from the source tree, CLI components should be organized as:
- **Application/PrivateForkApp.swift**: Main app entry point, needs CLI mode detection [Source: docs/architecture/source-tree.md#application]
- **Services/Protocols/KeychainServiceProtocol.swift**: Already exists for credential validation [Source: docs/architecture/source-tree.md#services]
- **Services/Implementations/KeychainService.swift**: Already exists for credential operations [Source: docs/architecture/source-tree.md#services]
- **Utilities/**: New CLI utilities for argument parsing and validation [Source: docs/architecture/source-tree.md#utilities]

### Component Standards
CLI components must follow the service pattern with protocols:
- CLI argument parsing should be wrapped in a service following the protocol pattern
- Services must be injected into any ViewModels or CLI controllers
- All CLI operations must use async/await for consistency
[Source: docs/architecture/component-standards.md#component-template]

### Coding Standards Requirements
- **Protocol-Oriented Programming (POP)**: Create CLIServiceProtocol for argument parsing and validation [Source: docs/architecture/coding-standards.md#critical-coding-rules]
- **Dependency Injection**: CLI services must be injectable for testing [Source: docs/architecture/coding-standards.md#critical-coding-rules]
- **Asynchronous Operations**: All credential validation must use async/await [Source: docs/architecture/coding-standards.md#critical-coding-rules]
- **Result Type**: All CLI operations that can fail must return Result<Success, Error> [Source: docs/architecture/coding-standards.md#critical-coding-rules]
- **Single Responsibility**: Separate concerns for argument parsing, validation, and credential checking [Source: docs/architecture/coding-standards.md#critical-coding-rules]

### Technology Stack
- **Framework**: Foundation for command-line argument parsing [Source: docs/architecture/tech-stack.md]
- **Language**: Swift 5.10+ [Source: docs/architecture/tech-stack.md]
- **Dependencies**: Native Apple frameworks only (Foundation, Security for Keychain) [Source: docs/architecture/tech-stack.md]
- **CLI Tools**: Consider Swift ArgumentParser if complex parsing needed, otherwise use CommandLine [Source: docs/architecture/tech-stack.md]

### API Integration Pattern
CLI services must follow the established service pattern:
```swift
protocol CLIServiceProtocol {
    func parseArguments(_ args: [String]) async -> Result<CLIArguments, Error>
    func validateCredentials() async -> Result<Bool, Error>
}
```
[Source: docs/architecture/api-integration.md#service-template]

### State Management for CLI
CLI mode should not use @Published properties but still follow the Result pattern:
- CLI operations return Results instead of updating UI state
- Error handling outputs to stderr, success to stdout
- No SwiftUI dependencies in CLI code paths
[Source: docs/architecture/state-management.md#state-management-template]

### File Locations and Naming
- **CLI Service Protocol**: PrivateFork/Services/Protocols/CLIServiceProtocol.swift
- **CLI Service Implementation**: PrivateFork/Services/Implementations/CLIService.swift
- **CLI Arguments Model**: PrivateFork/Models/CLIArguments.swift
- **CLI Utilities**: PrivateFork/Utilities/CLIUtilities.swift
[Source: docs/architecture/component-standards.md#naming-conventions]

### Integration with Existing Services
This story builds on existing KeychainService:
- Reuse KeychainServiceProtocol for credential validation
- Follow the same dependency injection pattern established in MainViewModel
- Use the same error handling patterns established in SettingsViewModel
[Source: Previous stories 1.2, 1.3c]

### Testing

**Test File Locations:**
- PrivateForkTests/Services/CLIServiceTests.swift (new file for CLI service testing)
- PrivateForkTests/Models/CLIArgumentsTests.swift (new file for CLI arguments testing)
- PrivateForkTests/Integration/CLIIntegrationTests.swift (new file for CLI integration testing)
[Source: docs/architecture/testing-requirements.md#component-test-template]

**Test Standards:**
- All CLI services require comprehensive unit tests following Given-When-Then structure using XCTest
- Mock KeychainService for credential validation testing
- Test coverage must include argument parsing, validation, and error scenarios
- CLI operations must be tested in isolation from GUI components
[Source: docs/architecture/testing-requirements.md#testing-best-practices]

**Testing Frameworks and Patterns:**
- Framework: XCTest (native macOS testing framework)
- Pattern: Given-When-Then structure for test organization
- Mocking: Use mock services for KeychainService dependencies
- Async Testing: Use expectation-based testing for async credential validation

**Specific Testing Requirements for This Story:**
- Argument parsing: Test valid/invalid URL and path inputs
- Credential validation: Test scenarios with/without saved credentials
- Error handling: Test all exit code scenarios and error messages
- Integration: Test CLI mode detection and headless operation
- Edge cases: Test malformed arguments, missing parameters, invalid paths

## Change Log
| Date       | Version | Description                           | Author |
|------------|---------|---------------------------------------|--------|
| 2025-07-17 | 0.1     | Initial CLI foundation story from 1.4 split | SM     |

## Dev Agent Record
*This section is populated by the development agent during implementation*

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

## QA Results